
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>&lt;no title&gt; &#8212; 6.2410 -- Laboratory for Quantum Information Science and Engineering</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ket": ["\\left|{#1}\\right\\rangle", 1], "bra": ["\\left\\langle{#1}\\right|", 1], "braket": ["\\left\\langle{#1}\\middle|{#2}\\right\\rangle", 2], "adagger": ["\\hat{a}^{\\dagger}"], "ahat": ["\\hat{a}"], "bdagger": ["\\hat{b}^{\\dagger}"], "bhat": ["\\hat{b}"], "cdagger": ["\\hat{c}^{\\dagger}"], "chat": ["\\hat{c}"], "ddagger": ["\\hat{d}^{\\dagger}"], "dhat": ["\\hat{d}"], "edagger": ["\\hat{e}^{\\dagger}"], "ehat": ["\\hat{e}"], "fdagger": ["\\hat{f}^{\\dagger}"], "fhat": ["\\hat{f}"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Problem 1" href="LAB-IBM-Qiskit-Prelab.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo-ibm.jpg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">6.2410 -- Laboratory for Quantum Information Science and Engineering</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    6.2410 – Laboratory for Quantum Information Science and Engineering
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Introductory Material
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="BASICS-quantum-optics-basics.html">
   BASICS – Quantum Optics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="BASICS-quantum-information.html">
   BASICS – Quantum Information
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Interference and Entanglement
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="T3E1-TEXT--entanglement-interference-quantum-enhanced-sensing.html">
   TEXT – Interference, Entanglement and Quantum-Enhanced Metrology
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="T3E1-LAB--entanglement-interference-quantum-enhanced-sensing.html">
   LAB – Interference, Entanglement and Quantum-Enhanced Metrology
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Quantum Key Distribution
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="T2E1-TEXT-QKD-simulation.html">
   BB84 Lab Write-up
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="T2E1-LAB-BB84.html">
   QKD Lab - Instructions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="T2E1-TEXT-Intro-to-SPDC-and-HBT.html">
   Latex Headers
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="T2E1-LAB-Single-photon-and-HBT.html">
   Hanbury - Brown Twiss Lab Instructions
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Solid State Spins
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="T3E3-LAB-Cavity_QED_sensor.html">
   Cavity-coupled quantum electrodynamic (QED) sensor
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Quantum Computing (QISKIT)
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="LAB-IBM-Qiskit-Prelab.html">
   Problem 1
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="git@github.mit.edu:pdkeat2/6.2410-lab.git"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="git@github.mit.edu:pdkeat2/6.2410-lab.git/issues/new?title=Issue%20on%20page%20%2FLAB-IBM-Qiskit.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/LAB-IBM-Qiskit.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="simple visible nav section-nav flex-column">
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1><no title></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="simple visible nav section-nav flex-column">
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <p>*The following Qiskit exercises are adapted from the official IBM Qiskit textbook.</p>
<h1 style="font-size:35px;
        color:black;
        ">Part 1: Quantum Circuits</h1><p>Prerequisite</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/documentation/tutorials/circuits/1_getting_started_with_qiskit.html">Qiskit basics</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-states/atoms-computation.html">Ch.1.2 The Atoms of Computation</a></p></li>
</ul>
<p>Other relevant materials</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/documentation/install.html#access-ibm-quantum-systems">Access IBM Quantum Systems</a></p></li>
<li><p><a class="reference external" href="https://quantum-computing.ibm.com/docs/manage/backends/configuration">IBM Quantum Systems Configuration</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/documentation/apidoc/transpiler.html">Transpile</a></p></li>
<li><p><a class="reference external" href="https://quantum-computing.ibm.com/docs/manage/account/ibmq">IBM Quantum account</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/documentation/apidoc/circuit.html">Quantum Circuits</a></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<h2 style="font-size:24px;">Classical logic gates with quantum circuits</h2>
<br>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
  <p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
    <p style=" padding: 0px 0px 10px 10px;
              font-size:16px;">Create quantum circuit functions that can compute the XOR, AND, NAND and OR gates using the NOT gate (expressed as x in Qiskit), the CNOT gate (expressed as cx in Qiskit) and the Toffoli gate (expressed as ccx in Qiskit) .</p>
</div>
<p>An implementation of the <code class="docutils literal notranslate"><span class="pre">NOT</span></code> gate is provided as an example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">NOT</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An NOT gate.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        inp (str): Input, encoded in qubit 0.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        QuantumCircuit: Output NOT circuit.</span>
<span class="sd">        str: Output value measured from qubit 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># A quantum circuit with a single qubit and a single classical bit</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># We encode &#39;0&#39; as the qubit state |0⟩, and &#39;1&#39; as |1⟩</span>
    <span class="c1"># Since the qubit is initially |0⟩, we don&#39;t need to do anything for an input of &#39;0&#39;</span>
    <span class="c1"># For an input of &#39;1&#39;, we do an x to rotate the |0⟩ to |1⟩</span>
    <span class="k">if</span> <span class="n">inp</span><span class="o">==</span><span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
    <span class="c1"># barrier between input state and gate operation </span>
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    
    <span class="c1"># Now we&#39;ve encoded the input, we can do a NOT on it using x</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1">#barrier between gate operation and measurement</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    
    <span class="c1"># Finally, we extract the |0⟩/|1⟩ output of the qubit and encode it in the bit c[0]</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
    
    <span class="c1"># We&#39;ll run the program on a simulator</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
    <span class="c1"># Since the output will be deterministic, we can use just a single shot to get it</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">qc</span><span class="p">,</span> <span class="n">output</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Test the function</span>
<span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]:</span>
    <span class="n">qc</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">NOT</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;NOT with input&#39;</span><span class="p">,</span><span class="n">inp</span><span class="p">,</span><span class="s1">&#39;gives output&#39;</span><span class="p">,</span><span class="n">out</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h3 style="font-size: 20px">&#128211; XOR gate</h3>
<p>Takes two binary strings as input and gives one as output.</p>
<p>The output is ‘0’ when the inputs are equal and  ‘1’ otherwise.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">XOR</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An XOR gate.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        inpt1 (str): Input 1, encoded in qubit 0.</span>
<span class="sd">        inpt2 (str): Input 2, encoded in qubit 1.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        QuantumCircuit: Output XOR circuit.</span>
<span class="sd">        str: Output value measured from qubit 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
  
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">qc</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">inp1</span><span class="o">==</span><span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inp2</span><span class="o">==</span><span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># barrier between input state and gate operation </span>
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    
    <span class="c1">##################################################</span>
    <span class="c1"># this is where your program for quantum XOR gate goes</span>

    
    
    
    
    
    
    
    
    <span class="c1">##################################################</span>
    
    <span class="c1"># barrier between input state and gate operation </span>
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    
    <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># output from qubit 1 is measured</span>
  
    <span class="c1">#We&#39;ll run the program on a simulator</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
    <span class="c1">#Since the output will be deterministic, we can use just a single shot to get it</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
  
    <span class="k">return</span> <span class="n">qc</span><span class="p">,</span> <span class="n">output</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Test the function</span>
<span class="k">for</span> <span class="n">inp1</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">inp2</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]:</span>
        <span class="n">qc</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">XOR</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span> <span class="n">inp2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;XOR with inputs&#39;</span><span class="p">,</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">,</span><span class="s1">&#39;gives output&#39;</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h3 style="font-size: 20px">&#128211; AND gate</h3>
<p>Takes two binary strings as input and gives one as output.</p>
<p>The output is <code class="docutils literal notranslate"><span class="pre">'1'</span></code> only when both the inputs are <code class="docutils literal notranslate"><span class="pre">'1'</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">AND</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An AND gate.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        inpt1 (str): Input 1, encoded in qubit 0.</span>
<span class="sd">        inpt2 (str): Input 2, encoded in qubit 1.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        QuantumCircuit: Output AND circuit.</span>
<span class="sd">        str: Output value measured from qubit 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">qc</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
  
    <span class="k">if</span> <span class="n">inp1</span><span class="o">==</span><span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inp2</span><span class="o">==</span><span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

    <span class="c1">##################################################</span>
    <span class="c1"># this is where your program for quantum AND gate goes</span>
    
    
    
    
    
    
    
    
    
    
    <span class="c1">##################################################</span>

    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># output from qubit 2 is measured</span>
  
    <span class="c1"># We&#39;ll run the program on a simulator</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
    <span class="c1"># Since the output will be deterministic, we can use just a single shot to get it</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
  
    <span class="k">return</span> <span class="n">qc</span><span class="p">,</span> <span class="n">output</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Test the function</span>
<span class="k">for</span> <span class="n">inp1</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">inp2</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]:</span>
        <span class="n">qc</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">AND</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span> <span class="n">inp2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;AND with inputs&#39;</span><span class="p">,</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">,</span><span class="s1">&#39;gives output&#39;</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h3 style="font-size: 20px">&#128211; NAND gate</h3>
<p>Takes two binary strings as input and gives one as output.</p>
<p>The output is <code class="docutils literal notranslate"><span class="pre">'0'</span></code> only when both the inputs are <code class="docutils literal notranslate"><span class="pre">'1'</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">NAND</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An NAND gate.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        inpt1 (str): Input 1, encoded in qubit 0.</span>
<span class="sd">        inpt2 (str): Input 2, encoded in qubit 1.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        QuantumCircuit: Output NAND circuit.</span>
<span class="sd">        str: Output value measured from qubit 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">qc</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">inp1</span><span class="o">==</span><span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inp2</span><span class="o">==</span><span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    
    <span class="c1">##################################################</span>
    <span class="c1"># this is where your program for quantum NAND gate goes</span>
    
    
    

    
    
    
    
    
    
    <span class="c1">##################################################</span>
    
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># output from qubit 2 is measured</span>
  
    <span class="c1"># We&#39;ll run the program on a simulator</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
    <span class="c1"># Since the output will be deterministic, we can use just a single shot to get it</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span><span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
  
    <span class="k">return</span> <span class="n">qc</span><span class="p">,</span> <span class="n">output</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Test the function</span>
<span class="k">for</span> <span class="n">inp1</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">inp2</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]:</span>
        <span class="n">qc</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">NAND</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span> <span class="n">inp2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;NAND with inputs&#39;</span><span class="p">,</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">,</span><span class="s1">&#39;gives output&#39;</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h3 style="font-size: 20px">&#128211; OR gate</h3>
<p>Takes two binary strings as input and gives one as output.</p>
<p>The output is ‘1’ if either input is ‘1’.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">OR</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An OR gate.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        inpt1 (str): Input 1, encoded in qubit 0.</span>
<span class="sd">        inpt2 (str): Input 2, encoded in qubit 1.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        QuantumCircuit: Output XOR circuit.</span>
<span class="sd">        str: Output value measured from qubit 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">qc</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">inp1</span><span class="o">==</span><span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inp2</span><span class="o">==</span><span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
   
    <span class="c1">##################################################</span>
    <span class="c1"># this is where your program for quantum OR gate goes</span>
    
    
    
    
    
    
    
    
    
    
    <span class="c1">##################################################</span>
    
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># output from qubit 2 is measured</span>
  
    <span class="c1"># We&#39;ll run the program on a simulator</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
    <span class="c1"># Since the output will be deterministic, we can use just a single shot to get it</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span><span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    
    
  
    <span class="k">return</span> <span class="n">qc</span><span class="p">,</span> <span class="n">output</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Test the function</span>
<span class="k">for</span> <span class="n">inp1</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">inp2</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]:</span>
        <span class="n">qc</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">OR</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span> <span class="n">inp2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;OR with inputs&#39;</span><span class="p">,</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">,</span><span class="s1">&#39;gives output&#39;</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h1 style="font-size:35px;
        color:black;
        ">Part 2 Quantum Measurements</h1><p>Prerequisite</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-states/single-qubit-gates.html">Ch.1.4 Single Qubit Gates</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-gates/multiple-qubits-entangled-states.html">Ch.2.2 Multiple Qubits and Entangled States</a></p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=yuDxHJOKsVA&amp;list=PLOFEBzvs-Vvp2xg9-POLJhQwtVktlYGbY&amp;index=8">Mitigating Noise on Real Quantum Computers</a></p></li>
</ul>
<p>Other relevant materials</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.feynmanlectures.caltech.edu/III_12.html">Feynman Lectures Ch. III - 12</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html">Quantum Operation</a></p></li>
<li><p><a class="reference external" href="https://nonhermitian.org/kaleido/stubs/kaleidoscope.interactive.bloch_sphere.html#kaleidoscope.interactive.bloch_sphere">Interactive Bloch Sphere</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html">Ch.5.2 Measurement Error Mitigation</a></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">la</span>
<span class="kn">from</span> <span class="nn">qiskit.tools.monitor</span> <span class="kn">import</span> <span class="n">job_monitor</span>
<span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>
</pre></div>
</div>
</div>
</div>
<h2 style="font-size:24px;">Measuring the state of a qubit</h2>
<br>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
  <p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
    <p style=" padding: 0px 0px 10px 10px;
              font-size:16px;">Determine the Bloch components of a qubit.</p>
</div>
<p>Fundamental to the operation of a quantum computer is the ability to compute the Bloch components of a qubit or qubits. These components correspond to the expectation values of the Pauli operators <span class="math notranslate nohighlight">\(X, Y, Z\)</span>, and are important quantities for applications such as quantum chemistry and optimization.  Unfortunately, it is impossible to simultaneously compute these values, thus requiring many executions of the same circuit.  In addition, measurements are restricted to the computational basis (Z-basis) so that each Pauli needs to be rotated to the standard basis to access the x and y components.  Here we verify the methods by considering the case of a random vector on the Bloch sphere.</p>
<h3 style="font-size: 20px">&#128211; 1. Express the expectation values of the Pauli operators for an arbitrary qubit state $|q\rangle$ in the computational basis. </h3>
<p>The case for the expectation value of Pauli Z gate is given as an example.</p>
<p>Using the diagonal representation, also known as spectral form or orthonormal decomposition, of Pauli <span class="math notranslate nohighlight">\(Z\)</span> gate and the relations among the Pauli gates (see <a class="reference external" href="https://qiskit.org/textbook/ch-states/single-qubit-gates.html">here</a>), expectation values of <span class="math notranslate nohighlight">\( X, Y, Z \)</span> gates can be written as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\langle Z \rangle &amp;=\langle q | Z | q\rangle =\langle q|0\rangle\langle 0|q\rangle - \langle q|1\rangle\langle 1|q\rangle
=|\langle 0 |q\rangle|^2 - |\langle 1 | q\rangle|^2\\\\
\langle X \rangle &amp;= 
\\\\
\langle Y \rangle &amp;= 
\end{align}
\\
\end{split}\]</div>
<p>, respectively.</p>
<p>Therefore, the expectation values of the Paulis for a qubit state <span class="math notranslate nohighlight">\(|q\rangle\)</span> can be obtained by making a measurement in the standard basis after rotating the standard basis frame to lie along the corresponding axis. The probabilities of obtaining the two possible outcomes 0 and 1 are used to evaluate the desired expectation value as the above equations show.</p>
<h3 style="font-size: 20px">2. Measure the Bloch sphere coordinates of a qubit using the Aer simulator and plot the vector on the Bloch sphere.</h3><h4 style="font-size: 17px">&#128211;Step A. Create a qubit state using the circuit method, <code>initialize</code> with two random complex numbers as the parameter.</h4>
<p>To learn how to use the function <code class="docutils literal notranslate"><span class="pre">initialize</span></code>, check <a class="reference external" href="https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Arbitrary-initialization">here</a>. (go to the <code class="docutils literal notranslate"><span class="pre">arbitrary</span> <span class="pre">initialization</span></code> section.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1">#### your code goes here</span>












<span class="c1">##################################################</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211; Step B. Build the circuits to measure the expectation values of $X, Y, Z$ gate based on your answers to the question 1.  Run the cell below to estimate the Bloch sphere coordinates of the qubit from step A using the Aer simulator.</h4>
<p>The circuit for <span class="math notranslate nohighlight">\(Z\)</span> gate measurement is given as an example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># z measurement of qubit 0</span>
<span class="n">measure_z</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">measure_z</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>


<span class="c1"># x measurement of qubit 0</span>
<span class="n">measure_x</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1"># your code goes here</span>






<span class="c1">##################################################</span>

<span class="c1"># y measurement of qubit 0</span>
<span class="n">measure_y</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1"># your code goes here</span>






<span class="c1">##################################################</span>

<span class="n">shots</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">14</span> <span class="c1"># number of samples used for statistics</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
<span class="n">bloch_vector_measure</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">measure_circuit</span> <span class="ow">in</span> <span class="p">[</span><span class="n">measure_x</span><span class="p">,</span> <span class="n">measure_y</span><span class="p">,</span> <span class="n">measure_z</span><span class="p">]:</span>
    
    <span class="c1"># run the circuit with the selected measurement and get the number of samples that output each bit value</span>
    <span class="n">circ_trans</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">measure_circuit</span><span class="p">),</span> <span class="n">sim</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">circ_trans</span><span class="p">),</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

    <span class="c1"># calculate the probabilities for each bit value</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
            <span class="n">probs</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">output</span><span class="p">]</span><span class="o">/</span><span class="n">shots</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">probs</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
    <span class="n">bloch_vector_measure</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">probs</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">-</span>  <span class="n">probs</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># normalizing the Bloch sphere vector</span>
<span class="n">bloch_vector</span> <span class="o">=</span> <span class="n">bloch_vector_measure</span><span class="o">/</span><span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bloch_vector_measure</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The Bloch sphere coordinates are [</span><span class="si">{0:4.3f}</span><span class="s1">, </span><span class="si">{1:4.3f}</span><span class="s1">, </span><span class="si">{2:4.3f}</span><span class="s1">]&#39;</span>
      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">bloch_vector</span><span class="p">))</span>    
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_bloch_vector</span>

<span class="n">plot_bloch_vector</span><span class="p">(</span> <span class="n">bloch_vector</span> <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h2 style="font-size:24px;">Measuring Energy</h2>
<br>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
  <p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
    <p style=" padding: 0px 0px 10px 10px;
              font-size:16px;">Evaluate the energy levels of the hydrogen ground state using Aer simulator.</p>
</div>
<p>The energy of a quantum system can be estimated by measuring the expectation value of its Hamiltonian, which is a Hermitian operator, through the procedure we mastered in part 1.</p>
<p>The ground state of hydrogen is not defined as a single unique state but actually contains four different states due to the spins of the electron and proton. In part 2 of this lab, we evaluate the energy difference among these four states, which is from the <code class="docutils literal notranslate"><span class="pre">hyperfine</span> <span class="pre">splitting</span></code>, by computing the energy expectation value for the system of two spins with the Hamiltonian expressed in Pauli operators. For more information about <code class="docutils literal notranslate"><span class="pre">hyperfine</span> <span class="pre">structure</span></code>, see <a class="reference external" href="https://www.feynmanlectures.caltech.edu/III_12.html">here</a></p>
<p>Consider the system with two qubit interaction Hamiltonian <span class="math notranslate nohighlight">\(H = A(XX+YY+ZZ)\)</span> where <span class="math notranslate nohighlight">\(A = 1.47e^{-6} eV\)</span> and <span class="math notranslate nohighlight">\(X, Y, Z\)</span> are Pauli gates. Then the energy expectation value of the system can be evaluated by combining the expectation value of each term in the Hamiltonian.
In this case, <span class="math notranslate nohighlight">\(E = \langle H\rangle = A( \langle XX\rangle + \langle YY\rangle + \langle ZZ\rangle )\)</span>.</p>
<h3 style="font-size: 20px">&#128211; 1. Express the expectation value of each term in the Hamiltonian for an arbitrary two qubit state   $|\psi \rangle$ in the computational basis.</h3>
<p>The case for the term <span class="math notranslate nohighlight">\(\langle ZZ\rangle\)</span> is given as an example.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\langle ZZ\rangle &amp;=\langle \psi | ZZ | \psi\rangle =\langle \psi|(|0\rangle\langle 0| - |1\rangle\langle 1|)\otimes(|0\rangle\langle 0| - |1\rangle\langle 1|) |\psi\rangle
=|\langle 00|\psi\rangle|^2 - |\langle 01 | \psi\rangle|^2 - |\langle 10 | \psi\rangle|^2 + |\langle 11|\psi\rangle|^2\\\\
\langle XX\rangle &amp;= \\\\
\langle YY\rangle &amp;= 
\end{align}
\end{split}\]</div>
<h3 style="font-size: 20px">2. Measure the expected energy of the system using the Aer simulator when two qubits are entangled. Regard the bell basis, four different entangled states.</h3><h4 style="font-size: 17px">&#128211;Step A. Construct the circuits to prepare four different bell states.</h4>
<p>Let’s label each bell state as
$<span class="math notranslate nohighlight">\(
\begin{align}
Tri1 &amp;= \frac{1}{\sqrt2} (|00\rangle + |11\rangle)\\
Tri2 &amp;= \frac{1}{\sqrt2} (|00\rangle - |11\rangle)\\
Tri3 &amp;= \frac{1}{\sqrt2} (|01\rangle + |10\rangle)\\
Sing &amp;= \frac{1}{\sqrt2} (|10\rangle - |01\rangle)
\end{align}
\)</span>$</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># circuit for the state Tri1</span>
<span class="n">Tri1</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1"># your code goes here</span>





<span class="c1">##################################################</span>

<span class="c1"># circuit for the state Tri2</span>
<span class="n">Tri2</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1"># your code goes here</span>





<span class="c1">##################################################</span>

<span class="c1"># circuit for the state Tri3</span>
<span class="n">Tri3</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1"># your code goes here</span>





<span class="c1">##################################################</span>

<span class="c1"># circuit for the state Sing</span>
<span class="n">Sing</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1"># your code goes here</span>




<span class="c1">##################################################</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step B. Create the circuits to measure the expectation value of each term in the Hamiltonian based on your answer to the question 1.</h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &lt;ZZ&gt; </span>
<span class="n">measure_ZZ</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">measure_ZZ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="c1"># &lt;XX&gt;</span>
<span class="n">measure_XX</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1"># your code goes here</span>





<span class="c1">##################################################</span>

<span class="c1"># &lt;YY&gt;</span>
<span class="n">measure_YY</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1"># your code goes here</span>




<span class="c1">##################################################</span>
</pre></div>
</div>
</div>
</div>
 <h4 style="font-size: 17px">Step C. Execute the circuits on Aer simulator by running the cell below and evaluate the energy expectation value for each state.</h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">shots</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">14</span> <span class="c1"># number of samples used for statistics</span>

<span class="n">A</span> <span class="o">=</span> <span class="mf">1.47e-6</span> <span class="c1">#unit of A is eV</span>
<span class="n">E_sim</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">state_init</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Tri1</span><span class="p">,</span><span class="n">Tri2</span><span class="p">,</span><span class="n">Tri3</span><span class="p">,</span><span class="n">Sing</span><span class="p">]:</span>
    <span class="n">Energy_meas</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">measure_circuit</span> <span class="ow">in</span> <span class="p">[</span><span class="n">measure_XX</span><span class="p">,</span> <span class="n">measure_YY</span><span class="p">,</span> <span class="n">measure_ZZ</span><span class="p">]:</span>
    
        <span class="c1"># run the circuit with the selected measurement and get the number of samples that output each bit value</span>
        <span class="n">qc</span> <span class="o">=</span> <span class="n">state_init</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">measure_circuit</span><span class="p">)</span>
        <span class="n">qc_trans</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">sim</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_trans</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

        <span class="c1"># calculate the probabilities for each computational basis</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;00&#39;</span><span class="p">,</span><span class="s1">&#39;01&#39;</span><span class="p">,</span> <span class="s1">&#39;10&#39;</span><span class="p">,</span> <span class="s1">&#39;11&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">output</span><span class="p">]</span><span class="o">/</span><span class="n">shots</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="n">Energy_meas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">probs</span><span class="p">[</span><span class="s1">&#39;00&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">probs</span><span class="p">[</span><span class="s1">&#39;01&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">probs</span><span class="p">[</span><span class="s1">&#39;10&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">probs</span><span class="p">[</span><span class="s1">&#39;11&#39;</span><span class="p">]</span> <span class="p">)</span>
 
    <span class="n">E_sim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Energy_meas</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run this cell to print out your results</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Energy expectation value of the state Tri1 : </span><span class="si">{:.3e}</span><span class="s1"> eV&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E_sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Energy expectation value of the state Tri2 : </span><span class="si">{:.3e}</span><span class="s1"> eV&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E_sim</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Energy expectation value of the state Tri3 : </span><span class="si">{:.3e}</span><span class="s1"> eV&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E_sim</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Energy expectation value of the state Sing : </span><span class="si">{:.3e}</span><span class="s1"> eV&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E_sim</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</div>
 <h4 style="font-size: 17px">Step D. Understanding the result. </h4>
<p>If you found the energy expectation values successfully, you would have obtained exactly the same value, <span class="math notranslate nohighlight">\(A (= 1.47e^{-6} eV)\)</span>, for the triplet states, <span class="math notranslate nohighlight">\(|Tri1\rangle, |Tri2\rangle, |Tri3\rangle\)</span> and one lower energy level, <span class="math notranslate nohighlight">\(-3A (= -4.41e^{-6} eV)\)</span> for the singlet state <span class="math notranslate nohighlight">\(|Sing\rangle\)</span>.</p>
<p>What we have done here is measuring the energies of the four different spin states corresponding to the ground state of hydrogen and observed <code class="docutils literal notranslate"><span class="pre">hyperfine</span> <span class="pre">structure</span></code> in the energy levels caused by spin-spin coupling.  This tiny energy difference between the singlet and triplet states is the reason for the famous 21-cm wavelength radiation used to map the structure of the galaxy.</p>
<p>In the cell below, we verify the wavelength of the emission from the transition between the triplet states and singlet state.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># reduced plank constant in (eV) and the speed of light(cgs units)</span>
<span class="n">hbar</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">4.1357e-15</span><span class="p">,</span> <span class="mf">3e10</span>

<span class="c1"># energy difference between the triplets and singlet</span>
<span class="n">E_del</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">E_sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">E_sim</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># frequency associated with the energy difference</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">E_del</span><span class="o">/</span><span class="n">hbar</span>

<span class="c1"># convert frequency to wavelength in (cm) </span>
<span class="n">wavelength</span> <span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">f</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The wavelength of the radiation from the transition</span><span class="se">\</span>
<span class="s1"> in the hyperfine structure is : </span><span class="si">{:.1f}</span><span class="s1"> cm&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wavelength</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<h2 style="font-size:24px;">Quantum teleportation</h2>
<br>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
  <p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
    <p style=" padding: 0px 0px 10px 10px;
              font-size:16px;">To show how quantum teleportation is performed and how Pauli correction is made depending on the measurement result.</p>
</div>
<p>For this exercise, we will see how quantum teleportation is performed using an entangled state as a resource. Importantly, to transfer one qubit faithfully to another, an additional Pauli rotation needs to be applied <span class="math notranslate nohighlight">\(\textit{depending on the measurement result of the original qubit}\)</span>.</p>
 <h4 style="font-size: 17px">Step A. Generate a random single qubit and plot it on the Bloch sphere. </h4>
<p>Hint: qiskit.quantum_info may have useful methods.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># your code goes here</span>
</pre></div>
</div>
</div>
</div>
 <h4 style="font-size: 17px">Step B. Create a quantum teleportation circuit. </h4>
<p>Construct a quantum circuit that has <em>two</em> qubits. One is the random single qubit <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> produced above, and another is a qubit initialized as <span class="math notranslate nohighlight">\(|0\rangle\)</span> and will be mapped to <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>, i.e. <span class="math notranslate nohighlight">\(|0\rangle\rightarrow |\psi\rangle\)</span>. The Qiskit chapter on quantum teleportation may be helpful: <a class="reference external" href="https://qiskit.org/textbook/ch-algorithms/teleportation.html">https://qiskit.org/textbook/ch-algorithms/teleportation.html</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1"># your code goes here</span>














<span class="c1">##################################################</span>
</pre></div>
</div>
</div>
</div>
 <h4 style="font-size: 17px">Step C. Plot the teleported qubit. </h4>
<p>Plot the teleported qubit on a Bloch sphere and confirm you indeed have recovered the same state as one shown in Step A.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1"># your code goes here</span>





<span class="c1">##################################################</span>
</pre></div>
</div>
</div>
</div>
<h1 style="font-size:35px;
        color:black;
        ">Part 3 Accuracy of Quantum Phase Estimation</h1><p>Prerequisite</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-algorithms/quantum-fourier-transform.html">Ch.3.5 Quantum Fourier Transform</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html">Ch.3.6 Quantum Phase Estimation</a></p></li>
</ul>
<p>Other relevant materials</p>
<ul class="simple">
<li><p>[QCQI] Michael A. Nielsen and Isaac L. Chuang. 2011. Quantum Computation and Quantum Information</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>
<span class="kn">from</span> <span class="nn">qiskit.tools.monitor</span> <span class="kn">import</span> <span class="n">job_monitor</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<h2 style="font-size:24px;">Performance of Quantum Phase Estimation</h2>
<br>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
  <p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
    <p style=" padding: 0px 0px 10px 10px;
              font-size:16px;">Investigate the relationship between the number of qubits required for the desired accuracy of the phase estimation with high probability.</p>
</div>
<p>The accuracy of the estimated value through Quantum Phase Estimation (QPE) and its probability of success depend on the number of qubits employed in QPE circuits. Therefore, one might want to know the necessary number of qubits to achieve the targeted level of QPE performance, especially when the phase that needs to be determined cannot be decomposed in a finite bit binary expansion.
In Part 1 of this lab, we examine the number of qubits required to accomplish the desired accuracy and the probability of success in determining the phase through QPE.</p>
<h3 style="font-size: 20px">1. Find the probability of obtaining the estimation for a phase value accurate to $2^{-2}$ successfully with four counting qubits.</h3> <h4 style="font-size: 17px">&#128211;Step A. Set up the QPE circuit with four counting qubits and save the circuit to the variable 'qc4'.  Execute 'qc4' on a Aer simulator.  Plot the histogram of the result.</h4><p>Check the QPE chapter in Qiskit textbook ( go to <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">Example:</span> <span class="pre">Getting</span> <span class="pre">More</span> <span class="pre">Precision</span></code> section <a class="reference external" href="https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html#3.-Example:-Getting-More-Precision-">here</a> ) for the circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qft</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates an n-qubit QFT circuit&quot;&quot;&quot;</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">swap_registers</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">qubit</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">circuit</span>
    <span class="k">def</span> <span class="nf">qft_rotations</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs qft on the first n qubits in circuit (without swaps)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">circuit</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">cp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">qubit</span><span class="p">),</span> <span class="n">qubit</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">qft_rotations</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    
    <span class="n">qft_rotations</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">swap_registers</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circuit</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Start your code to create the circuit, qc4</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Run this cell to simulate &#39;qc4&#39; and to plot the histogram of the result</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">20000</span>
<span class="n">count_qc4</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">qc4</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">count_qc4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Having performed <code class="docutils literal notranslate"><span class="pre">Step</span> <span class="pre">A</span></code> successfully, you will have obtained a distribution similar to the one shown below with the highest probability at <code class="docutils literal notranslate"><span class="pre">0101</span></code> which corresponds to the estimated <span class="math notranslate nohighlight">\(\phi\)</span> value, <code class="docutils literal notranslate"><span class="pre">0.3125</span></code>.</p>
<p>Since the number of counting qubits used for the circuit is four, the best estimated value should be accurate to <span class="math notranslate nohighlight">\(\delta = 2^{-4} = 0.0625\)</span>.  However, there are multiple possible outcomes as <span class="math notranslate nohighlight">\(\theta = 1/3\)</span> cannot be expressed in a finite number of bits, the estimation by QPE here is not always bounded by this accuracy.</p>
<p>Running the following cell shows the same histogram but with all possible estimated <span class="math notranslate nohighlight">\(\phi\)</span> values on the x-axis.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">phi_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">count_qc4</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
<span class="n">key_new</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">phi_est</span><span class="p">))</span>
<span class="n">count_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">key_new</span><span class="p">,</span> <span class="n">count_qc4</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">count_new</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Suppose the outcome of the final measurement is <span class="math notranslate nohighlight">\(m\)</span>, and let <span class="math notranslate nohighlight">\(b\)</span> the best estimation which is <code class="docutils literal notranslate"><span class="pre">0.3125</span></code> for this case.</strong></p>
<h4 style="font-size: 17px">&#128211;Step B. Find $e$, the maximum difference in integer from the best estimation <code>0101</code> so that all the outcomes, 'm's, would approximate $\phi$ to an accuracy $2^{-2}$ when $|m - b| \leq \frac{e}{2^{t}}$. </h4><p>In this case, the values of <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are <span class="math notranslate nohighlight">\(4\)</span> and <span class="math notranslate nohighlight">\(0.3125\)</span>, respectively.</p>
<p>For example, under <span class="math notranslate nohighlight">\(e = 1\)</span>, the considered outcomes are <code class="docutils literal notranslate"><span class="pre">0100</span></code>, <code class="docutils literal notranslate"><span class="pre">0101</span></code>, <code class="docutils literal notranslate"><span class="pre">0110</span></code> which correspond to the values of <span class="math notranslate nohighlight">\(m\)</span>: <span class="math notranslate nohighlight">\(0.25,~0.312,~0.375\)</span>, respectively, and all of them approximate the value <span class="math notranslate nohighlight">\(\frac{1}{3}\)</span> to an accuracy <span class="math notranslate nohighlight">\(2^{-2}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your code goes here</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step C. Compute the probability of obtaining an approximation correct to an accuracy $2^{-2}$.  Verify that the computed probability value is larger or equal to $1- \frac{1}{2(2^{(t-n)}-2)}$ where $t$ is the number of counting bits and the $2^{-n}$ is the desired accuracy. </h4><p>Now it is easy to evaluate the probability of the success from the histogram since all the outcomes that approximate <span class="math notranslate nohighlight">\(\phi\)</span> to the accuracy <span class="math notranslate nohighlight">\(2^{-2}\)</span> can be found based on the maximum difference <span class="math notranslate nohighlight">\(e\)</span> from the best estimate.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your code goes here</span>
</pre></div>
</div>
</div>
</div>
<h3 style="font-size: 20px">2. Compute the probability of success for the accuracy $2^{-2}$ when the number of counting qubits, $t$, varies from four to nine. Compare your result with the equation $t=n+log(2+\frac{1}{2\epsilon})$ when $2^{-n}$ is the desired accuracy and $\epsilon$ is 1 - probability  of success.</h3> <p>The following plot shows the relationship between the number of counting qubit, t, and the minimum probability of success to approximate the phase to an accuracy <span class="math notranslate nohighlight">\(2^{-2}\)</span>.  Check the Ch. 5.2.1 Performance and requirements in <code class="docutils literal notranslate"><span class="pre">[QCQI]</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="n">t_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">9.5</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span>
<span class="n">p_min</span> <span class="o">=</span> <span class="n">y</span><span class="p">(</span><span class="n">t_q</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_q</span><span class="p">,</span> <span class="n">p_min</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$p_</span><span class="si">{min}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t: number of counting qubits&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;probability of success for the accuracy $2^{-2}$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Probability of success for different number of counting qubits&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step A. Construct QPE circuit to estimate $\phi$ when $\phi = 1/3$ with for the different number of counting qubits, $t$, when $t = [4, 5, 6, 7, 8, 9]$. Store all the circuits in a list variable 'circ' to simulate all the circuits at once as we did in Lab2. </h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your Code to create the list variable &#39;circ&#39; goes here</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run this cell to simulate `circ` and plot the histograms of the results</span>

<span class="n">results</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="n">n_circ</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
<span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_circ</span><span class="p">)]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">n_circ</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">40</span><span class="p">))</span>
<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_circ</span><span class="p">):</span>
    <span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step B. Determine $e$, the maximum difference in integer from the best estimation for the different number of counting qubits, $t = [4, 5, 6, 7, 8, 9]$. Verify the relationship $e=2^{t-n}-1$ where $n=2$ since the desired accuracy is $2^{-2}$ in this case. </h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your Code goes here</span>
</pre></div>
</div>
</div>
</div>
<p>If you successfully calculated <span class="math notranslate nohighlight">\(e\)</span> values for all the counting qubits, <span class="math notranslate nohighlight">\(t=[4,5,6,7,8,9]\)</span>, you will be able to generate the following graph that verifies the relationship <span class="math notranslate nohighlight">\(e = 2^{t-2} -1\)</span> with the <span class="math notranslate nohighlight">\(e\)</span> values that you computed.</p>
<h4 style="font-size: 17px">&#128211;Step C. Evaluate the probability of success estimating $\phi$ to an accuracy $2^{-2}$ for all the values of $t$, the number of counting qubits. Save the probabilities to the list variable, 'prob_success'.  </h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your code to create the list variable, &#39;prob_success&#39;,  goes here</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step D. Overlay the results of Step C on the graph that shows the relationship between the number of counting qubits, $t$, and the minimum probability of success to approximate the phase to an accuracy $2^{-2}$. Understand the result.  </h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your code goes here</span>
</pre></div>
</div>
</div>
</div>
<p>Your plot should be similar to the above one.
The line plot in the left panel shows the minimum success probability to estimate <span class="math notranslate nohighlight">\(\phi\)</span> within the accuracy <span class="math notranslate nohighlight">\(2^{-2}\)</span> as the number of counting qubits varies. The overlaid orange dots are the same values, but from the simulation, which confirms the relationship the line plot represents as the lower bound.  The right panel displays the same result but zoomed by adjusting the y-axis range.</p>
<p>The following graph exhibits the relationships with different accuracy levels.  The relationship, <span class="math notranslate nohighlight">\(t=n+log(2+\frac{1}{2\epsilon})\)</span>, indicates the number of counting qubits <span class="math notranslate nohighlight">\(t\)</span> to estimate <span class="math notranslate nohighlight">\(\phi\)</span> to an accuracy <span class="math notranslate nohighlight">\(2^{-2}\)</span> with probability of success at least <span class="math notranslate nohighlight">\(1-\epsilon\)</span>, as we validated above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">5.1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">prob_success_n</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="n">prob_n2</span><span class="p">,</span> <span class="n">prob_n3</span><span class="p">,</span> <span class="n">prob_n4</span>  <span class="o">=</span> <span class="n">prob_success_n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prob_success_n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">prob_success_n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">prob_n2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">prob_n3</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">prob_n4</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="s1">&#39;--&#39;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.05</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t: number of counting qubits&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;probability of success for the accuracy $2^{-n}$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;n = 2&#39;</span><span class="p">,</span> <span class="s1">&#39;n = 3&#39;</span><span class="p">,</span> <span class="s1">&#39;n = 4&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h1 style="font-size:35px;
        color:black;
        ">Part 4 Quantum Error Correction </h1>
<p>Prerequisite</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-quantum-hardware/error-correction-repetition-code.html#Storing-qubits">5.1 Introduction to Quantum Error Correction</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html">3.6 Quantum Phase Estimation</a></p></li>
</ul>
<p>Other relevant materials</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/documentation/stubs/qiskit.quantum_info.Statevector.html#qiskit.quantum_info.Statevector.from_instruction">Statevector method</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/documentation/tutorials/circuits/2_plotting_data_in_qiskit.html#Plot-State">qsphere</a></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_state_qsphere</span><span class="p">,</span> <span class="n">plot_bloch_vector</span>

<span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">Statevector</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h2 style="font-size:24px;"> 3-qubit code </h2>
<br>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
  <p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
    <p style=" padding: 0px 0px 10px 10px;
              font-size:16px;"> Create circuits for 3-qubit code that encodes a one qubit state into a three qubit code state and utilize partiy check to detect and localise either bit-flip ( X ) or phase-flip ( Z ) errors on a single qubit in the codes.</p>
</div><h3 style="font-size: 20px"> 1. Detect and locate a single bit-flip ( X ) error utilizing 3-qubit code and parity check circuit.</h3><h4 style="font-size: 17px">&#128211;Step A. Create a circuit to encode the state $|\psi\rangle = \frac{1}{\sqrt{2}}(|0\rangle + i|1\rangle)$ into 3-qubit code state, $\frac{1}{\sqrt{2}}(|000\rangle + i|111\rangle)$ to be protected from one bit-flip ( X ) error.</h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc_3qx</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1">### your code goes here. ###</span>










<span class="c1">##################################################</span>

<span class="c1">#######</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step B. Plot the 3-qubit code state produced by the above circuit, <code>qc_3qx</code> on the qsphere to validate the encoding.  </h4><p>The state displayed on the qshpere should match the 3-qubit code state for <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> upto a global phase.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### your code goes here ###</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">Step C. Implement the parity check gates to detect and localize a single bit flip error on the code qubits.</h4><p>Following operation will apply a single bit flip error on the code. Execute the cells below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">apply_err</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">):</span>
    
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Error&#39;</span><span class="p">)</span>
    <span class="n">which_qubit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">err</span><span class="o">==</span><span class="s1">&#39;bit&#39;</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">which_qubit</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">err</span><span class="o">==</span><span class="s1">&#39;phase&#39;</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">which_qubit</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    
    <span class="n">err</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">to_gate</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">err</span><span class="p">,</span> <span class="n">which_qubit</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">err</span><span class="p">,</span> <span class="n">which_qubit</span> <span class="o">=</span> <span class="n">apply_err</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;bit&#39;</span><span class="p">)</span>

<span class="n">qc_3qx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>📓 Apply the parity check gates on the circuit <code class="docutils literal notranslate"><span class="pre">qc</span></code> with the extra registers for the appropriate number of auxiliary qubits and syndrome bits to locate a bit-flip ( X ) error on a single qubit in the code. ( For 3 qubit code, the number of syndrome bit states is equal to the number of possible single bit-flip error, including no error.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Execute this cell to add the extra registers</span>

<span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;number of auxiliary qubits ( / syndrome bits): &#39;</span><span class="p">))</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;auxiliary&#39;</span><span class="p">))</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">ClassicalRegister</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;syndrome&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Apply the parity check gates and measure the parities on the syndrome bits to localize a single bit-flip ( X ) error on the code.</span>

<span class="c1">##################################################</span>
<span class="c1">### your code goes here. ###</span>










<span class="c1">##################################################</span>

<span class="n">qc_3qx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step D. Complete the dictionary in the following cell to make the syndrome look-up table for all single bit-flip errors on the three qubit code.</h4><p>The key of the dictionary is a two-bit string for the syndrome and the values reprent the corresponding a single qubit error gates with the appropriate qubit indicies on the code circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#### complete the dictionary ###</span>

<span class="n">table_syndrome</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;00&#39;</span><span class="p">:</span> <span class="s1">&#39;I[0]I[1]I[2]&#39;</span><span class="p">,</span> <span class="s1">&#39;01&#39;</span><span class="p">:</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> 
                  <span class="s1">&#39;10&#39;</span><span class="p">:</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="s1">&#39;11&#39;</span><span class="p">:</span><span class="s1">&#39; I[0]X[1]I[2] &#39;</span><span class="p">}</span>

<span class="c1">######</span>
<span class="nb">print</span><span class="p">(</span><span class="n">table_syndrome</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Run the following cell to execute the circuit <code class="docutils literal notranslate"><span class="pre">qc_xerr</span></code> on <code class="docutils literal notranslate"><span class="pre">aer_simulator</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc_3qx_trans</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc_3qx</span><span class="p">,</span> <span class="n">sim</span><span class="p">)</span>
<span class="n">syndrome</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_3qx_trans</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">syndrome</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step E. Find the single bit-error and two bit-error based on the measured syndrome bits and check your answer with the value of the variable, <code>which_qubit</code>.</h4><p>Run the following cell.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">your_answer</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Enter the index of the code qubit that underwent bit-flip error: &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">which_qubit</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">your_answer</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">Step F. Identify the logical $X$ ( $X_{L}$ ) and logical $Z$ ( $Z_{L}$ ) operators for the three qubit bit flip code.</h4><p>📓 Find the logical <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(X_{L}\)</span>, for three qubit bit flip code where <span class="math notranslate nohighlight">\(X_{L}|000\rangle = |111\rangle\)</span>. Construct a circuit to perform <span class="math notranslate nohighlight">\(X_{L}|0\rangle_{L}\)</span> and simulate it to check if the state produced by the circuit is <span class="math notranslate nohighlight">\(|1\rangle_{L}\)</span>, where the logical code word basis states, <span class="math notranslate nohighlight">\(|0\rangle_{L}\)</span> and <span class="math notranslate nohighlight">\(|1\rangle_{L}\)</span>, are encoded as <span class="math notranslate nohighlight">\(|0\rangle_{L} = |000\rangle, ~ |1\rangle_{L}=|111\rangle\)</span> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">##################################################</span>
<span class="c1">### your code goes here ###</span>








<span class="c1">##################################################</span>

<span class="n">bits_out</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_XL</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bits_out</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>📓 Find the minimal weight encoded logical <span class="math notranslate nohighlight">\(Z\)</span> ( there are four equivalent <span class="math notranslate nohighlight">\(Z_{L}\)</span>s. ) where <span class="math notranslate nohighlight">\(Z_{L}|+\rangle_{L} = |-\rangle_{L}\)</span> and <span class="math notranslate nohighlight">\(|+\rangle_{L} = |0\rangle_{L} + |1\rangle_{L}, ~~ |-\rangle_{L} = |0\rangle_{L} - |1\rangle_{L}\)</span> . What is the distance of the three qubit bit flip code? Can it detect or/and correct a single phase-flip ( Z ) error?</p>
<ul class="simple">
<li><p>weight: the weight of an operator is the number of qubits that it acts non-trivially on. ( E.g. <span class="math notranslate nohighlight">\(Z\otimes Z\otimes I\)</span> has weight 2. )</p></li>
<li><p>distance of a code: the minimum number of errors that will change one logical code word basis state to another or the maximum number of errors that can be detected.</p></li>
</ul>
<p><strong>Your answer :</strong></p>
<h3 style="font-size: 20px">2. Construct a circuit that encodes one qubit state into 3-qubit code states and can locate a single phase-flip ( Z ) error through parity check.</h3><h4 style="font-size: 17px">&#128211;Step A. Create a circuit to encode the state $|\psi\rangle = \frac{1}{\sqrt{2}}(|0\rangle + i|1\rangle)$ into a 3-qubit code to protect it from one phase-flip ( Z ) error.</h4><p>Here, the logical code word basis states, <span class="math notranslate nohighlight">\(|0\rangle_{L}\)</span> and <span class="math notranslate nohighlight">\(|1\rangle_{L}\)</span>, are encoded as, <span class="math notranslate nohighlight">\(|0\rangle_{L} = |+++\rangle\)</span> and <span class="math notranslate nohighlight">\(|1\rangle_{L} = |---\rangle\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc_3qz</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1">##################################################</span>
<span class="c1">### your code goes here. ###</span>








<span class="c1">##################################################</span>

<span class="n">qc_3qz</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step B. Implement the parity check gates to detect and localize a single phase flip error on the code qubits.</h4><p>Extra registers need to be added on the circuit for the auxiliary qubits and syndrome bits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">err</span><span class="p">,</span> <span class="n">which_qubit</span> <span class="o">=</span> <span class="n">apply_err</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">)</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="c1">##################################################</span>
<span class="c1">### your code goes here ###</span>











<span class="c1">##################################################</span>

<span class="n">qc_3qz</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Excute the cell below to run the circuit <code class="docutils literal notranslate"><span class="pre">qc_zerr</span></code> on <code class="docutils literal notranslate"><span class="pre">aer_simulator</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc_3qz_trans</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc_3qz</span><span class="p">,</span> <span class="n">sim</span><span class="p">)</span>
<span class="n">syndrome</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_3qz_trans</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">syndrome</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step C. Find the single phase-error based on the measured syndrome bits and check your answer with the value of the variable, <code>which_qubit</code>.</h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">your_answer</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Enter the index of the code qubit that underwent phase-flip error: &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">which_qubit</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">your_answer</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<h2 style="font-size:24px;"> Repetition code as a stabilizer code </h2>
<br>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
  <p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
    <p style=" padding: 0px 0px 10px 10px;
              font-size:16px;"> Stabilizer formalism defines Quantum Error Correcting Codes ( QECC ) by the set of operators that stabilize the logical code word states, instead of its state vectors. Interpreting quantum error correcting codes in terms of its stabilizers is beneficial since the decription of QECC is more concise and encoded logical operators can be obtained systematically. In the part 2 of this lab, we re-construct the repetition code as a stabilizer code to understand this new method.</p>
</div><h3 style="font-size: 20px">&#128211; 1. Find the two independent stablizer operators for the 3 qubit code states, $|000\rangle,~ |111\rangle$.</h3><ul class="simple">
<li><p>The stabilizer operator <span class="math notranslate nohighlight">\(S\)</span> of a n-qubit state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> is the set of n-qubit Pauli operators that satisfy <span class="math notranslate nohighlight">\(S|\psi\rangle = |\psi\rangle\)</span>.</p></li>
</ul>
<p><strong>Your answer :</strong></p>
<h3 style="font-size: 20px"> 2. Construct a Quantum Phase Estimation ( QPE ) circuit to produce the eigenvalues for one of the stablizer, $I\otimes Z\otimes Z$.</h3><h4 style="font-size: 17px">&#128211;Step A. What are the eigenvalues of the operator $I\otimes Z \otimes Z$? Determine the minimum number of counting qubits needed in QPE circuit to estimate the eigenvalue accurately.</h4><p><strong>Your answer :</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your answer goes here</span>
<span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;The number of counting qubit: &#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step B. Complete the following code to build the QPE circuit. </h4><p>Note: The QPE circuit essentially performs the projective measurement of the operator <span class="math notranslate nohighlight">\(I\otimes Z\otimes Z\)</span> on the <span class="math notranslate nohighlight">\(|\psi\rangle = |0\rangle \otimes |0\rangle \otimes|+\rangle\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc0</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">qc0</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc0</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

<span class="c1">##################################################</span>
<span class="c1">## your code goes here ##</span>










<span class="c1">##################################################</span>

<span class="n">qc0</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">qc0</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">counts_qc0</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc0</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">8192</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts_qc0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">&#128211;Step C. Using the circuit identities, convert QPE part of the above circuit <code>qc0</code> to the one with only CNOT gates.</h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc1</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">qc1</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc1</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

<span class="c1">##################################################</span>
<span class="c1">## your code goes here ##</span>











<span class="c1">##################################################</span>

<span class="n">qc1</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">qc1</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">counts_qc1</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc1</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">8192</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts_qc1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px"> Summary </h4><p>An error correcting code can be defined as an independent set of stabilizers and the errors are dectected by the measurement outcomes of this set of stabilizers.</p>
<p>Here, in part2 of this lab, we checked that there are two indepndent stabilizers for the three qubit repetition code, and measuring a stabilizer is equivalent to checking a parity. Therefore, to obtain set of syndromes for a single bit error detection with the three qubit repetition code, the circuit for encoding an arbitrary single qubit state and measuring two stabilizers has the folllowing structure.</p>
<p><img alt="image.png" src="attachment:image.png" /></p>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="LAB-IBM-Qiskit-Prelab.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Problem 1</p>
        </div>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Dirk Englund, Marc Baldo, Donnie Keathley<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>