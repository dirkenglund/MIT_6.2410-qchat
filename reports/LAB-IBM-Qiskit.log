Traceback (most recent call last):
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/jupyter_cache/executors/utils.py", line 51, in single_nb_execution
    executenb(
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 1204, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/nbclient/util.py", line 84, in wrapped
    return just_run(coro(*args, **kwargs))
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/nbclient/util.py", line 62, in just_run
    return loop.run_until_complete(coro)
  File "/home/dkeathley/anaconda3/lib/python3.8/asyncio/base_events.py", line 616, in run_until_complete
    return future.result()
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 663, in async_execute
    await self.async_execute_cell(
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 965, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 862, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# z measurement of qubit 0
measure_z = QuantumCircuit(1,1)
measure_z.measure(0,0)


# x measurement of qubit 0
measure_x = QuantumCircuit(1,1)

##################################################
# your code goes here






##################################################

# y measurement of qubit 0
measure_y = QuantumCircuit(1,1)

##################################################
# your code goes here






##################################################

shots = 2**14 # number of samples used for statistics
sim = Aer.get_backend('aer_simulator')
bloch_vector_measure = []
for measure_circuit in [measure_x, measure_y, measure_z]:
    
    # run the circuit with the selected measurement and get the number of samples that output each bit value
    circ_trans = transpile(qc.compose(measure_circuit), sim)
    counts = sim.run(qc.compose(circ_trans), shots=shots).result().get_counts()

    # calculate the probabilities for each bit value
    probs = {}
    for output in ['0','1']:
        if output in counts:
            probs[output] = counts[output]/shots
        else:
            probs[output] = 0
            
    bloch_vector_measure.append( probs['0'] -  probs['1'] )

# normalizing the Bloch sphere vector
bloch_vector = bloch_vector_measure/la.norm(bloch_vector_measure)

print('The Bloch sphere coordinates are [{0:4.3f}, {1:4.3f}, {2:4.3f}]'
      .format(*bloch_vector))    
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mQiskitError[0m                               Traceback (most recent call last)
[0;32m/tmp/ipykernel_2623915/1041644693.py[0m in [0;36m<cell line: 35>[0;34m()[0m
[1;32m     37[0m     [0;31m# run the circuit with the selected measurement and get the number of samples that output each bit value[0m[0;34m[0m[0;34m[0m[0;34m[0m[0m
[1;32m     38[0m     [0mcirc_trans[0m [0;34m=[0m [0mtranspile[0m[0;34m([0m[0mqc[0m[0;34m.[0m[0mcompose[0m[0;34m([0m[0mmeasure_circuit[0m[0;34m)[0m[0;34m,[0m [0msim[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0;32m---> 39[0;31m     [0mcounts[0m [0;34m=[0m [0msim[0m[0;34m.[0m[0mrun[0m[0;34m([0m[0mqc[0m[0;34m.[0m[0mcompose[0m[0;34m([0m[0mcirc_trans[0m[0;34m)[0m[0;34m,[0m [0mshots[0m[0;34m=[0m[0mshots[0m[0;34m)[0m[0;34m.[0m[0mresult[0m[0;34m([0m[0;34m)[0m[0;34m.[0m[0mget_counts[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m     40[0m [0;34m[0m[0m
[1;32m     41[0m     [0;31m# calculate the probabilities for each bit value[0m[0;34m[0m[0;34m[0m[0;34m[0m[0m

[0;32m~/anaconda3/lib/python3.8/site-packages/qiskit/result/result.py[0m in [0;36mget_counts[0;34m(self, experiment)[0m
[1;32m    287[0m                 [0mdict_list[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mstatevector[0m[0;34m.[0m[0mStatevector[0m[0;34m([0m[0mvec[0m[0;34m)[0m[0;34m.[0m[0mprobabilities_dict[0m[0;34m([0m[0mdecimals[0m[0;34m=[0m[0;36m15[0m[0;34m)[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[1;32m    288[0m             [0;32melse[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m
[0;32m--> 289[0;31m                 [0;32mraise[0m [0mQiskitError[0m[0;34m([0m[0;34mf'No counts for experiment "{repr(key)}"'[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    290[0m [0;34m[0m[0m
[1;32m    291[0m         [0;31m# Return first item of dict_list if size is 1[0m[0;34m[0m[0;34m[0m[0;34m[0m[0m

[0;31mQiskitError[0m: 'No counts for experiment "0"'
QiskitError: 'No counts for experiment "0"'

